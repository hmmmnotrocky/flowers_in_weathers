---
const { 
  numberOfFlowers = 4,
  fillPetals = false,

  /* Petal count */
  minPetals = 5,
  maxPetals = 8,

  /* Stem */
  minStemHeight = 80,
  maxStemHeight = 120,

  /* Petal geometry */
  minPetalRadius = 30,
  maxPetalRadius = 90,
  minPetalWidth = 30,
  maxPetalWidth = 80,

  /* Bouquet spread */
  maxOffsetX = 25

} = Astro.props;

/* ===============================
   Helpers
================================ */

function rand(min, max) {
  return Math.random() * (max - min) + min;
}

function randInt(min, max) {
  return Math.floor(rand(min, max + 1));
}

function polar(cx, cy, r, angleDeg) {
  const rad = (angleDeg - 90) * Math.PI / 180;
  return {
    x: cx + r * Math.cos(rad),
    y: cy + r * Math.sin(rad)
  };
}

/* ===============================
   Color Families
================================ */

const baseHues = [
//   330, // pink
  30,  // orange
//   280, // purple
//   55,  // yellow
//   210  // blue
];

/* ===============================
   Base Anchor
================================ */

const baseCenterX = 100;
const stemBottomY = 95;

/* ===============================
   Generate Flowers
================================ */

const flowers = [];

for (let i = 0; i < numberOfFlowers; i++) {

  const petals = randInt(minPetals, maxPetals);
  const stemHeight = rand(minStemHeight, maxStemHeight);
  const petalRadius = rand(minPetalRadius, maxPetalRadius);
  const petalWidth = rand(minPetalWidth, maxPetalWidth);

  const startingAngle = rand(0, 360);

  /* X Offset */
  const offsetX = rand(-maxOffsetX, maxOffsetX);
  const centerX = baseCenterX + offsetX;
  const centerY = stemBottomY - stemHeight;

  /* Unique phase for asynchronous sway */
  const phase = Math.random() * Math.PI * 2;

  /* Color Variation */
  const baseHue = baseHues[randInt(0, baseHues.length - 1)];
  const hue = baseHue + rand(-30, 30);
  const color = `hsl(${hue}, 70%, 50%)`;

  /* Center circle: hue within Â±20 of flower, size proportional to petal width */
  const centerHue = (hue + rand(-20, 20) + 360) % 360;
  const centerColor = `hsl(${centerHue}, 65%, 45%)`;
  const centerRadius = petalWidth * 0.08;

  const petalPaths = [];

  for (let j = 0; j < petals; j++) {
    const segment = 360 / petals;
    const angle = segment * j + startingAngle;

    const c1 = polar(centerX, centerY, petalWidth, angle - 20);
    const c2 = polar(centerX, centerY, petalWidth, angle + 20);

    const path = `
      M ${centerX} ${centerY}
      C ${c1.x} ${c1.y}
        ${c2.x} ${c2.y}
        ${centerX} ${centerY}
    `;

    petalPaths.push(path);
  }

  flowers.push({
    centerX,
    centerY,
    petalPaths,
    color,
    phase,
    centerRadius,
    centerColor
  });
}
---

<g id="flower-bouquet">
  {flowers.map((flower) => (
    <g 
      class="sway-group"
      data-phase={flower.phase}
      style={`transform-origin: ${flower.centerX}px ${stemBottomY}px;`}
    >

      <!-- Stem -->
      <path
        d={`
          M ${flower.centerX} ${stemBottomY}
          Q ${flower.centerX} ${stemBottomY - 20}
            ${flower.centerX} ${flower.centerY}
        `}
        fill="none"
        stroke={flower.color}
        stroke-width="2"
        stroke-linecap="round"
      />

      <!-- Petals -->
      <g 
        stroke={flower.color} 
        fill={fillPetals ? flower.color : "none"} 
        stroke-width="2"
      >
        {flower.petalPaths.map(p => <path d={p} />)}
      </g>

      <!-- Center circle -->
      <circle
        cx={flower.centerX}
        cy={flower.centerY}
        r={flower.centerRadius}
        fill={flower.centerColor}
      />

    </g>
  ))}
</g>

<script define:vars={{ numberOfFlowers, fillPetals, minPetals, maxPetals, minStemHeight, maxStemHeight, minPetalRadius, maxPetalRadius, minPetalWidth, maxPetalWidth, maxOffsetX }}>
  (function () {
    const SVG_NS = 'http://www.w3.org/2000/svg';
    const stemBottomY = 95;
    const baseCenterX = 100;
    const baseHues = [30];

    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }
    function randInt(min, max) {
      return Math.floor(rand(min, max + 1));
    }
    function polar(cx, cy, r, angleDeg) {
      const rad = (angleDeg - 90) * Math.PI / 180;
      return {
        x: cx + r * Math.cos(rad),
        y: cy + r * Math.sin(rad)
      };
    }

    function el(tag, attrs) {
      const node = document.createElementNS(SVG_NS, tag);
      if (attrs) for (const k in attrs) node.setAttribute(k, attrs[k]);
      return node;
    }

    const flowers = [];
    for (let i = 0; i < numberOfFlowers; i++) {
      const petals = randInt(minPetals, maxPetals);
      const stemHeight = rand(minStemHeight, maxStemHeight);
      const petalRadius = rand(minPetalRadius, maxPetalRadius);
      const petalWidth = rand(minPetalWidth, maxPetalWidth);
      const startingAngle = rand(0, 360);
      const offsetX = rand(-maxOffsetX, maxOffsetX);
      const centerX = baseCenterX + offsetX;
      const centerY = stemBottomY - stemHeight;
      const phase = Math.random() * Math.PI * 2;
      const baseHue = baseHues[randInt(0, baseHues.length - 1)];
      const hue = baseHue + rand(-30, 30);
      const color = 'hsl(' + hue + ', 70%, 50%)';
      const centerHue = (hue + rand(-20, 20) + 360) % 360;
      const centerColor = 'hsl(' + centerHue + ', 65%, 45%)';
      const centerRadius = petalWidth * 0.08;

      const petalPaths = [];
      for (let j = 0; j < petals; j++) {
        const segment = 360 / petals;
        const angle = segment * j + startingAngle;
        const c1 = polar(centerX, centerY, petalWidth, angle - 20);
        const c2 = polar(centerX, centerY, petalWidth, angle + 20);
        petalPaths.push('M ' + centerX + ' ' + centerY + ' C ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + centerX + ' ' + centerY);
      }

      flowers.push({
        centerX, centerY, petalPaths, color, phase, centerRadius, centerColor
      });
    }

    function render() {
      const container = document.getElementById('flower-bouquet');
      if (!container) return;

      while (container.firstChild) container.removeChild(container.firstChild);

      flowers.forEach(function (f) {
        const group = el('g', {
          'class': 'sway-group',
          'data-phase': String(f.phase),
          'style': 'transform-origin: ' + f.centerX + 'px ' + stemBottomY + 'px'
        });

        const stemPath = el('path', {
          d: 'M ' + f.centerX + ' ' + stemBottomY + ' Q ' + f.centerX + ' ' + (stemBottomY - 20) + ' ' + f.centerX + ' ' + f.centerY,
          fill: 'none',
          stroke: f.color,
          'stroke-width': '2',
          'stroke-linecap': 'round'
        });
        group.appendChild(stemPath);

        const petalsGroup = el('g', {
          stroke: f.color,
          fill: fillPetals ? f.color : 'none',
          'stroke-width': '2'
        });
        f.petalPaths.forEach(function (d) {
          petalsGroup.appendChild(el('path', { d: d }));
        });
        group.appendChild(petalsGroup);

        const circle = el('circle', {
          cx: String(f.centerX),
          cy: String(f.centerY),
          r: String(f.centerRadius),
          fill: f.centerColor
        });
        group.appendChild(circle);

        container.appendChild(group);
      });
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', render);
    } else {
      render();
    }
  })();
</script>
